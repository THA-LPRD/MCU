<!doctype html>

<html>
	<head>
	
        <meta charset="utf-8">

        <meta name="LPRD" content="Bitmap Übertragung">

        <link rel="stylesheet" type="text/css" href="style.css">

</head>


    <body>

      <header>

        <img src="LPRD-Logo.bmp" alt="Logo"> 
        <h1> Low-Power-Raumanzeige</h1>
        
       
        
        
    </header>

    <div id="trenner"> </div>

    <div class="container">
        <main>
            

  <!--      <p>Lade eine Textdatei hoch und drücke auf "Daten absenden", um sie auf dem Display anzuzeigen.</p>
            <form action="/api/v1/upload" method="POST" enctype="multipart/form-data">
                <input type="file" id="myFile" name="bitmap" accept=".txt">
                <br></br>
                <input type="submit">
            </form>

            <br>
        -->

        <div id="intro">
            <h2>
                Vielen Dank, dass Sie sich für einen <br>LPRD-Display entschieden haben. <br></br>
                Sie haben 2 Möglichkeiten <br>personalisierte Inhalte darzustellen:<br>
                Upload eines <a href="#png-upload">PNGs</a> oder  <a href="#list-header">Design via HTML</a>.

            </h2>

        </div>



        <br></br>

        <h3 id="png-upload"><u>Hochladen eines PNGs:</u></h3>

        <p id="pngText">Bitte laden Sie ein PNG in dem <b>exakten Pixelformat</b> Ihres Displays hoch.</p>


        <form id="uploadForm">
            <input type="file" id="fileInput" accept="image/png" onchange="displayImage()"/> 
        
        </form>

        <br><br>
        <button id="pngUploadButton" onclick="convertAndUploadPng()">Upload an Display</button>
      
        
          <div id="imageContainer"></div>

          <br><br>


            <ol>
                <h3 id="list-header"><u>Eigenes Design mit HTML erstellen:</u></h3>

                <li>HTML-Code in das Textfeld eingeben <br>(Achtung hierbei auf die Pixel-Auflösung des Displays, die Layoutgröße muss <b>genau der Pixelanzahl</b> entsprechen)</li>
                <li>Eine Vorschau Ihres HTML-Designs können Sie im 2. Feld sehen, sie wird automatisch aktualisiert</li>
                <li>Wenn Sie zufrieden mit Ihrem Design sind, können Sie über den Upload-Button Ihr fertiges HTML-Layout an das Display schicken</li>
                <li>Nun müssen Sie nur noch einen kurzen Moment warten, bis das Display seinen Inhalt aktualisiert hat</li>
            </ol> 

    

            <div id="designByHtml">
                Bitte geben Sie in das Textfeld Ihren HTML Code ein.

            </div>



            <textarea id="inputText" rows="20" cols="97" oninput="convertToHTML()"></textarea> 

            <br></br>

            <b>Ihre Design-Vorschau:</b>

            <div id="previewContainer">
                <div id="preview"></div>
            </div>


            <button onclick="convertAndUpload()">Upload an Display</button>
            <br><br>

            <img id="previewImg" src="" />

        </main>
    </div>

   

    <script src="./html2canvas.min.js"></script>

    <script>

        var byteArray = [];


      function displayImage() {
      var fileInput = document.getElementById('fileInput');
      var file = fileInput.files[0];

      if (file) {
        var reader = new FileReader();

        reader.onload = function(e) {
          var imageContainer = document.getElementById('imageContainer');
          imageContainer.innerHTML = '<img src="' + e.target.result + '" alt="Uploaded Image" />';
        }

        reader.readAsDataURL(file);
      } else {
        alert('Bitte wählen Sie eine PNG-Datei aus.');

    }
}

    function convertAndUploadPng() {
        html2canvas(document.getElementById('imageContainer'), { scale: 1 }).then(canvas => {
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        var byteArray = convertImageDataToByteArray(imageData);
        console.log(byteArray);


                var url = '/api/v1/uploadbmp';

                // Konfiguration der Fetch-Anfrage
                var requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: byteArray })
                };

                // Senden der POST-Anfrage mit der Fetch-API
                 fetch(url, requestOptions)
                     .then(function (response) {
                        // Überprüfen, ob die Anfrage erfolgreich war (Statuscode 200)
                         if (!response.ok) {
                         throw new Error('Fehler beim Senden der Daten. Statuscode: ' + response.status);
                        }
                 return response.json(); // Rückgabe des JSON-Datenstroms der Antwort
                })
                .then(function (data) {
                    console.log('Daten erfolgreich gesendet:', data);
                })
                .catch(function (error) {
                    console.error('Fehler beim Senden der Daten:', error);
                });
            });

       
    }
        
        function convertToHTML() {
            var inputText = document.getElementById("inputText").value;
            var preview = document.getElementById("preview");

            // Set the preview content
            preview.innerHTML = inputText;
        }


        function convertAndUpload() {
            html2canvas(document.querySelector("#preview"), { scale: 1 }).then(canvas => {
                // document.body.appendChild(canvas);
                // var img = canvas.toDataURL("image/png");
                // document.getElementById('previewImg').src = img;
                var img = canvas.toDataURL("image/png");
                document.getElementById('previewImg').src = img;
                var context = canvas.getContext("2d");
                // console.log(context.getImageData(0, 0, 800, 400));
                console.log(createImageBitmap(document.getElementById('previewImg'), 0, 0, 800, 480).data);
                var context = canvas.getContext("2d");
                var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                console.log(canvas.width, canvas.height);

                byteArray = convertImageDataToByteArray(imageData);
                console.log(byteArray);

                // console.log(context.getImageData(0, 0, 800, 400));
                // console.log(createImageBitmap(document.getElementById('previewImg'), 0, 0, 800, 480).data);

                var url = '/api/v1/uploadbmp';

                // Konfiguration der Fetch-Anfrage
                var requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: byteArray })
                };

                // Senden der POST-Anfrage mit der Fetch-API
                 fetch(url, requestOptions)
                     .then(function (response) {
                        // Überprüfen, ob die Anfrage erfolgreich war (Statuscode 200)
                         if (!response.ok) {
                         throw new Error('Fehler beim Senden der Daten. Statuscode: ' + response.status);
                        }
                 return response.json(); // Rückgabe des JSON-Datenstroms der Antwort
                })
                .then(function (data) {
                    console.log('Daten erfolgreich gesendet:', data);
                })
                .catch(function (error) {
                    console.error('Fehler beim Senden der Daten:', error);
                });
            });
        }

        // Helper function to find the closest color for a given pixel
        function findClosestColor(pixel) {
            // Extract RGB components from the pixel
            let r = pixel[0];
            let g = pixel[1];
            let b = pixel[2];
            let a = pixel[3];

            // Calculate the luminance
            let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

            // Determine the closest color based on luminance and alpha
            if (a < 128) {
                return 0x00; // Transparent (Black)
            } else {
                if (luminance < 128) {
                    // Dark colors: Black or Red
                    if (r > g && r > b) {
                        return 0x03; // Red
                    } else {
                        return 0x00; // Black
                    }
                } else {
                    // Light colors: White or Yellow
                    if (r > g && r > b) {
                        return 0x02; // Yellow
                    } else {
                        return 0x01; // White
                    }
                }
            }
        }

        function convertImageDataToByteArray(imageData) {
            let data = imageData.data;
            let hexByteArray = [];

            for (let i = 0; i < data.length; i += 16) {
                let byte = 0x00;

                // Process 4 consecutive pixels at a time
                for (let j = 0; j < 16; j += 4) {
                    let pixel = [data[i + j], data[i + j + 1], data[i + j + 2], data[i + j + 3]];

                    // Find the closest color for the pixel and append it to the byte
                    byte = (byte << 2) | findClosestColor(pixel);
                }

                // Push the byte to the hexByteArray
                hexByteArray.push(byte);
            }

            return hexByteArray;
        }

 

    </script>






    <footer>
        <p>© Projektarbeit Low-Power-Raumanzeige LPRD SoSe24</p>
    </footer>

      

    </body>
</html>